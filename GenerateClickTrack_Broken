import java.util.Arrays;
import java.util.ArrayList;
import java.util.Collections;

public class GenerateClickTrack {

	float[] spacedVals;
	float sr, click_freq, click_duration, angular_freq;
	int hop_length;
	int[] times;
	
	public GenerateClickTrack(float sr, int hop_length, float click_freq, float click_duration, int[] times) {
		angular_freq = 2 * (float) Math.PI * click_freq / sr;
		this.sr = sr;
		this.hop_length = hop_length;
		this.click_freq = click_freq;
		this.click_duration = click_duration;
		
		this.times = times;
	}
	
	/*
	*	The following methods are to create a default click signal.
	*	There is no current functionality for a custom given click signal
	*/
	
	//TODO: modify this for different bases. (?)
	public static float[] GenerateLogSpace(int min, int max, int logBins, double logarithmicBase) {
	       //double logarithmicBase = Math.E;
	       double logMin = Math.log(min);
	       double logMax = Math.log(max);
	       double delta = (logMax - logMin) / logBins;
	       double deltaTot = 0;
	       float [] spacedVals = new float[logBins];
	       for (int i = 0; i <= logBins; ++i) {
	           spacedVals[i] = (float) Math.pow(logarithmicBase, logMin + deltaTot);
	           deltaTot += delta;
	       }	       
	       return spacedVals;
	}
	
	
	//modifies spacedVals field. Python equivalent: np.sin(angular_freq * np.arange(len(spacedVals)))
	public void arange() {		
		for (int i = 0; i < spacedVals.length; i++) {
			//multiply each index value by the sine of its (index multiplied by angular_freq)
			spacedVals[i] = spacedVals[i] * (float) Math.sin(i * angular_freq);
		}
	}
	
	// Overloaded Method to generate indices from a given int array of timestamps. 
	public int[] timeToSamples () {
		for (int i = 0; i < times.length; i++) {
			times[i] = times[i] * 22050;
		}		
		return times;
	}
	
	// Generates indices from given a given int array of timestamps.
	public int[] timeToSamples (float sr) {
		for (int i = 0; i < times.length; i++) {
			times[i] = (int) (times[i] * sr);
		}		
		return times;
	}
	
  // This method is not functional
	public int[] placeClicks (int[] clicks) {
		int[] positions = timeToSamples();
		
		//find max of primitive array
		int maxVal = Arrays.stream(positions).max().getAsInt();
				
		//int length = maxVal + 1; //1 is representative of click.shape[0]??
		int length = times.length; 
		
		//TODO: do we have to filter out positions past the length boundary? 
		ArrayList<Integer> newPositions = new ArrayList<Integer>();
		
		int sentinel = positions.length;
		for (int i = 0; i < sentinel; i++) {
			
			// if click is an optional array, end = i + click.shape[0] is equal to end = i?
			
			if (positions[sentinel] < length) {
				newPositions.add(positions[sentinel]); //reverse the order of newPositions
			}
			Collections.reverse(newPositions);
		}
		return ___ 
	}
}
