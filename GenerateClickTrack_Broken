import java.util.Arrays;
import java.util.ArrayList;
import java.util.Collections;

public class GenerateClickTrack {

	float[] spacedVals;
	float sr, click_freq, click_duration, angular_freq;
	int hop_length;
	int[] times;
	
	public GenerateClickTrack(float sr, int hop_length, float click_freq, float click_duration, int[] times) {
		angular_freq = 2 * (float) Math.PI * click_freq / sr;
		this.sr = sr;
		this.hop_length = hop_length;
		this.click_freq = click_freq;
		this.click_duration = click_duration;
		
		this.times = times;
	}
	
	/*
	*	The following methods are to create a default click signal.
	*	There is no current functionality for a custom given click signal
	*	We take a "times" array, which is an array of times to place clicks.
	*/
	
	//TODO: modify this for different bases. (?)
	public static float[] GenerateLogSpace(int min, int max, int logBins, double logarithmicBase) {
	       //double logarithmicBase = Math.E;
	       double logMin = Math.log(min);
	       double logMax = Math.log(max);
	       double delta = (logMax - logMin) / logBins;
	       double deltaTot = 0;
	       float [] spacedVals = new float[logBins];
	       for (int i = 0; i <= logBins; ++i) {
	           spacedVals[i] = (float) Math.pow(logarithmicBase, logMin + deltaTot);
	           deltaTot += delta;
	       }	       
	       return spacedVals;
	}
	
	
	//modifies spacedVals field. Python equivalent: np.sin(angular_freq * np.arange(len(spacedVals)))
	public void arange() {		
		for (int i = 0; i < spacedVals.length; i++) {
			//multiply each index value by the sine of its (index multiplied by angular_freq)
			spacedVals[i] = spacedVals[i] * (float) Math.sin(i * angular_freq);
		}
	}
	
	// Overloaded Method to generate indices from a given int array of timestamps. 
	public int[] timeToSamples () {
		for (int i = 0; i < times.length; i++) {
			times[i] = times[i] * 22050;
		}		
		return times;
	}
	
	// Generates indices from given a given int array of timestamps.
	public int[] timeToSamples (float sr) {
		for (int i = 0; i < times.length; i++) {
			times[i] = (int) (times[i] * sr);
		}		
		return times;
	}
	
	public ArrayList<Float> placeClicks (int[] clicks) {
		int[] positions = timeToSamples();
		
		//find max of primitive array
		//int maxVal = Arrays.stream(positions).max().getAsInt();
		
		ArrayList<Float> newPositions = new ArrayList<Float>(); //click_signal
		
		int sentinel = positions.length;
		for (int i = 0; i < sentinel; i++) {
			
			int end = i + spacedVals.length;
			
			if (end >= spacedVals.length) {
				
				//placing a click but just shortened to fit length
				for (int k = 0; k < spacedVals.length - i; k++) {
					newPositions.add(spacedVals[k]);
				}
			} else {				
				//appending clicks onto the click signal newPositions			
				//This is not correct. END is END. add AFTER END . DO WE NEED TO MAKE newPOSITIONS and ARRAY OF ZEROS? no. 
				for (int k = 0; k < spacedVals.length; k++) {
					newPositions.add(spacedVals[k]);
				}
			}			
		}
		return newPositions;
	}
}
